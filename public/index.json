[{"content":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找\nscan总共有这几种命令：scan、sscan、hscan、zscan，分别用于迭代数据库中的：数据库中所有键、集合键、哈希键、有序集合键，命令具体结构如下：\nscan cursor [MATCH pattern] [COUNT count] [TYPE type] sscan key cursor [MATCH pattern] [COUNT count] hscan key cursor [MATCH pattern] [COUNT count] zscan key cursor [MATCH pattern] [COUNT count] 2. scan scan cursor [MATCH pattern] [COUNT count] [TYPE type]，cursor表示游标，指查询开始的位置，count默认为10，查询完后会返回下一个开始的游标，当返回0的时候表示所有键查询完了\n127.0.0.1:6379[2]\u0026gt; scan 0 1) \u0026#34;3\u0026#34; 2) 1) \u0026#34;mystring\u0026#34; 2) \u0026#34;myzadd\u0026#34; 3) \u0026#34;myhset\u0026#34; 4) \u0026#34;mylist\u0026#34; 5) \u0026#34;myset2\u0026#34; 6) \u0026#34;myset1\u0026#34; 7) \u0026#34;mystring1\u0026#34; 8) \u0026#34;mystring3\u0026#34; 9) \u0026#34;mystring4\u0026#34; 10) \u0026#34;myset\u0026#34; 127.0.0.1:6379[2]\u0026gt; scan 3 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;myzadd1\u0026#34; 2) \u0026#34;mystring2\u0026#34; 3) \u0026#34;mylist2\u0026#34; 4) \u0026#34;myhset1\u0026#34; 5) \u0026#34;mylist1\u0026#34; MATCH可以采用模糊匹配找出自己想要查找的键，这里的逻辑是先查出20个，再匹配，而不是先匹配再查询，这里加上count 20是因为默认查出的10个数中可能不能包含所有的相关项，所以把范围扩大到查20个，我这里测试的键总共有15个\n127.0.0.1:6379[2]\u0026gt; scan 0 match mylist* count 20 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; TYPE可以根据具体的结构类型来匹配该类型的键\n127.0.0.1:6379[2]\u0026gt; scan 0 count 20 type list 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; 3. sscan sscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是集合类型的key\n127.0.0.1:6379[2]\u0026gt; sadd myset1 a b c d (integer) 4 127.0.0.1:6379[2]\u0026gt; smembers myset1 1) \u0026#34;d\u0026#34; 2) \u0026#34;a\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;b\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;d\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;b\u0026#34; 4) \u0026#34;a\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 match a 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;a\u0026#34; 4. hscan hscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是哈希类型的key\n127.0.0.1:6379[2]\u0026gt; hset myhset1 kk1 vv1 kk2 vv2 kk3 vv3 (integer) 3 127.0.0.1:6379[2]\u0026gt; hgetall myhset1 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 127.0.0.1:6379[2]\u0026gt; hscan myhset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 5. zscan zscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是有序集合类型的key\n127.0.0.1:6379[2]\u0026gt; zadd myzadd1 1 zz1 2 zz2 3 zz3 (integer) 3 127.0.0.1:6379[2]\u0026gt; zrange myzadd1 0 -1 withscores 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; 127.0.0.1:6379[2]\u0026gt; zscan myzadd1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; ","permalink":"http://localhost:1313/posts/tech/tech1/","summary":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找 scan总共有这几种命令：sca","title":"Redis scan命令学习"},{"content":"","permalink":"http://localhost:1313/posts/blog/blog/","summary":"","title":"Blog"},{"content":"","permalink":"http://localhost:1313/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"http://localhost:1313/posts/read/read/","summary":"","title":"Read"},{"content":"\u0026lt;div\u0026gt; 科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 \u0026lt;/div\u0026gt; ","permalink":"http://localhost:1313/posts/tech/tech/","summary":"\u0026lt;div\u0026gt; 科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代","title":"Tech"},{"content":"\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"http://localhost:1313/links/","summary":"👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\n英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"http://localhost:1313/about/","summary":"关于我 英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"},{"content":"","permalink":"http://localhost:1313/test.ya/","summary":"","title":""},{"content":"概述 frp 是什么？ frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。 具体参见官方文档:https://github.com/fatedier/frp/blob/dev/README_zh.md\nfrp的安装与部署 目前可以在 Github 的 Release 页面中下载到最新版本的客户端和服务端二进制文件，所有文件被打包在一个压缩包中。\n解压缩下载的压缩包，将其中的 frpc 拷贝到内网服务所在的机器上，将 frps 拷贝到具有公网 IP 的机器上，放置在任意目录。\n使用systemctl来控制frps后台自启动 这个方法比较好用，很方便 sudo vim /lib/systemd/system/frps.service 在frps.service里写入以下内容\n[Unit] Description=fraps service After=network.target syslog.target Wants=network.target [Service] Type=simple #启动服务的命令（此处写你的frps的实际安装目录） ExecStart=/your/path/frps -c /your/path/frps.ini [Install] WantedBy=multi-user.target 启动：systemctl start frps\n自启动： systemctl enable frps\n一台服务器穿透多台主机 frp支持一台公网服务器为多台内网主机提供内网穿透服务，可配置基于域名和基于端口的内网穿透。而只需更改客户端配置文件，服务端不用更改。\n通过自定义域名访问内网的web服务\nserver端配置：\n[common] bind_port = 7000 //服务端监听端口，等待客户端连接 vhost_http_port = 8080 修改客户端配置文件： A电脑 [common] server_addr = x.x.x.x server_port = 7000 [web] type = http local_ip = 127.0.0.1 local_port = 80 custom_domains = abc.test.com B电脑的配置信息如下 [common] server_addr = x.x.x.x server_port = 7000 [web2] type = http local_ip = 127.0.0.1 local_port = 8080 custom_domains = def.test.com 将abc.test.com和def.test.com解析到ip x.x.x.x或修改hosts文件\n配置完成后可通过abc.baidu.com:8080访问A电脑的80端口服务 通过def.baidu.com:8080访问B电脑的8080端口服务\n基于tcp实现多台客户机的内网穿透\nserver端配置：\n[common] bind_port = 7000 //服务端监听端口，等待客户端连接 客户端:\nA电脑： [common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 B电脑: [common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6001 通过x.x.x.x:6000访问A的22端口\n通过x.x.x.x:6001访问B的22端口\n更多功能参考https://frps.cn/11.html\n","permalink":"http://localhost:1313/posts/frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","summary":"概述 frp 是什么？ frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。 具体参见官方文档:https://github.com/fatedier/frp/blob/dev/","title":"frp实现多台主机内网穿透"},{"content":"\r在AS1、AS2、AS3上划分vlan as1 AS1(config)#vlan 10 AS1(config-vlan)#vlan 11 AS1(config-vlan)#int f0/1 AS1(config-if)#switchport mode access AS1(config-if)#switchport access vlan 11 AS1(config-if)#int g0/2 AS1(config-if)#switchport mode access AS1(config-if)#switchport access vlan 10 as2 AS2(config)#vlan 11 AS2(config-vlan)#vlan 22 AS2(config-vlan)#int f0/1 AS2(config-if)#switchport mode access AS2(config-if)#switchport access vlan 11 AS2(config-if)#int f0/2 AS2(config-if)#switchport mode access AS2(config-if)#switchport access vlan 22 as3 AS3(config)#vlan 22 AS3(config-vlan)#vlan 33 AS3(config-vlan)#int f0/1 AS3(config-if)#switchport mode access AS3(config-if)#switchport access vlan 22 AS3(config-if)#int f0/2 AS3(config-if)#switchport mode access AS3(config-if)#switchport access vlan 33 在CS上配置vlan和trunk 在CS配置vlan10、vlan11、vlan22、vlan33、vlan254，把G1/0/10和G1/0/11加入vlan254，G1/0/1、G1/0/2、G1/0/3设为trunk模式\nCS(config)#vlan 10 CS(config-vlan)#vlan 11 CS(config-vlan)#vlan 22 CS(config-vlan)#vlan 33 CS(config-vlan)#vlan 254 CS(config-vlan)#int g1/0/10 CS(config-if)#switchport mode access CS(config-if)#switchport access vlan 254 CS(config-if)#int g1/0/11 CS(config-if)#switchport mode access CS(config-if)#switchport access vlan 254 CS(config-if)#int g1/0/1 CS(config-if)#switchport trunk encapsulation dot1q CS(config-if)#switch mode trunk CS(config-if)#int g1/0/2 CS(config-if)#switchport trunk encapsulation dot1q CS(config-if)#switch mode trunk CS(config-if)#int g1/0/3 CS(config-if)#switchport trunk encapsulation dot1q CS(config-if)#switch mode trunk 在核心三层交换机CS上启用三层交换，并设置vlan间路由 CS(config)#ip routing//开启三层交换 CS(config)#int vlan 11 CS(config-if)#ip address 172.16.11.254 255.255.255.0 CS(config-if)#no shutdown CS(config-if)#int vlan 22 CS(config-if)#no shutdown CS(config-if)#int vlan 33 CS(config-if)#ip address 172.16.33.254 255.255.255.0 CS(config-if)#no shutdown CS(config-if)#int vlan 10 CS(config-if)#ip address 172.16.10.254 255.255.255.0 CS(config-if)#no shutdown CS(config-if)#int vlan 254 CS(config-if)#ip address 172.16.254.254 255.255.255.0 CS(config-if)#no shutdown 配置cs到fw的默认路由和fw到局域网的路由 CS(config)#ip route 0.0.0.0 0.0.0.0 172.16.1.1 FW(config)#ip route 172.16.0.0 0.0.255.255 172.16.1.2 此时局域网内vlan路由以配好，相同vlan间可通信。\n配置fw的出口路由和nat 静态路由 FW(config)#ip route 0.0.0.0 0.0.0.0 1.0.0.1 配置nat实现互联网访问 配置转换访问控制列表 配置nat转换 设定inside outside FW(config)#access-list 102 deny ip 172.16.0.0 0.0.255.255 192.168.1.0 0.0.0.255 FW(config)#access-list 102 permit ip 172.16.0.0 0.0.255.255 any FW(config)#ip nat inside source list 102 interface g0/0/0 overload FW(config)#int g0/0/0 FW(config-if)#ip nat outside FW(config-if)#int f0/0 FW(config-if)#ip nat inside 在ISP1、ISP2、ISP3开启ospf ISP1\nISP1(config)#route ospf 1 ISP1(config-router)#network 1.0.0.0 0.0.0.7 area 0 ISP1(config-router)#network 2.0.0.0 0.255.255.255 area 0 ISP1(config-router)#network 3.0.0.0 0.255.255.255 area 0 ISP2\nISP2(config)#route ospf 1 ISP2(config-router)#network 2.0.0.0 0.255.255.255 area 0 ISP2(config-router)#network 4.0.0.0 0.255.255.255 area 0 ISP2(config-router)#network 5.0.0.0 0.255.255.255 area 0 ISP3\nISP3(config)#route ospf 1 ISP3(config-router)#network 3.0.0.0 0.255.255.255 area 0 ISP3(config-router)#network 4.0.0.0 0.255.255.255 area 0 ISP3(config-router)#network 7.0.0.0 0.0.0.3 area 0 ISP3(config-router)#network 6.0.0.0 0.0.0.3 area 0 在分公司路由器Div_R配置默认路由和地址转换NAT div_R(config)#ip route 0.0.0.0 0.0.0.0 6.0.0.1 div_R(config)#access-list 102 deny ip 192.168.1.0 0.0.0.255 172.16.0.0 0.0.255.255 div_R(config)#access-list 102 permit ip 192.168.1.0 0.0.0.255 any div_R(config)#ip nat inside source list 102 interface g0/0/0 overload div_R(config)#int g0/0/0 div_R(config-if)#ip nat outside div_R(config-if)#int f0/0 div_R(config-if)#ip nat inside 配置总部到分公司端到端VPN 在总部FW配置端到端IPSec VPN，对端为6.0.0.2，认证方式为pre−share，key为123，加密方式为ah−md5−hmac esp−des，从总部172.16.0.0到分公司192.168.1.0的流量加密\nFW(config)#crypto isakmp enable FW(config)#crypto isakmp policy 1 FW(config-isakmp)#hash md5 FW(config-isakmp)#authentication pre-share FW(config)#crypto isakmp key 123 address 6.0.0.2 FW(config)#crypto ipsec transform-set testform ah-md5-hmac esp-des FW(config)#access-list 101 permit ip 172.16.0.0 0.0.255.255 192.168.1.0 0.0.0.255 FW(config)#crypto map testmap 1 ipsec-isakmp FW(config-crypto-map)#set peer 6.0.0.2 FW(config-crypto-map)#set transform-set testform FW(config-crypto-map)#match address 101 FW(config-crypto-map)#interface g0/0/0 FW(config-if)#crypto map testmap 在分公司div-R配置端到端IPSec VPN，对端为1.0.0.2，认证方式为pre−share，key为123，加密方式为ah−md5−hmac esp−des，从分公司192.168.1.0到总部172.16.0.0的流量加密\ndiv_R(config)#crypto isakmp enable div_R(config)#crypto isakmp policy 1 div_R(config-isakmp)#hash md5 div_R(config-isakmp)#authentication pre-share div_R(config)#crypto isakmp key 123 address 1.0.0.2 div_R(config)#crypto ipsec transform-set testform ah-md5-hmac esp-des div_R(config)#access-list 101 permit ip 192.168.1.0 0.0.0.255 172.16.0.0 0.0.255.255 div_R(config)#crypto map testmap 1 ipsec-isakmp div_R(config-crypto-map)#set peer 1.0.0.2 div_R(config-crypto-map)#set transform-set testform div_R(config-crypto-map)#match address 101 div_R(config-crypto-map)#int g0/0/0 div_R(config-if)#crypto map testmap 在总部出口路由器上配置静态地址映射，使得外网能访问dmz_srv服务器 在dmz_srv启用http服务，并在dmz_srv使用浏览器访问\n在FW配置静态地址映射，把172.16.2.1映射到1.0.0.3\nCODE ip nat inside source static tcp 172.16.2.1 80 1.0.0.3 80 int f0/1 ip nat inside 在PC4访问\nIPV6实验网配置 IPv6地址分配表\n设备名 **端口/**接口 IPv6****地址 掩码长度 网关 PC1 Fa0 2001::2 64 2001::1 PC2 Fa0 2001::3 64 2001::1 dmz_srv Fa0 2002::2 64 2002::1 IPv6_R G0/0 2001::1 64 无 FW F0/1 2002::1 64 无 配置PC1和PC2的IPv6地址\n配置IPv6_R路由器G0/0接口的IPv6地址并启用接口\nIPv6_R(config)#int g0/0 IPv6_R(config-if)#ipv6 address 2001::1/64 IPv6_R(config-if)#no shutdown 配置dmz_srv的IPv6地址\n配置FW路由器F0/1接口的IPv6地址\nFW(config)#int f0/1 FW(config-if)#ipv6 address 2001::1/64 FW(config-if)#no shutdown 配置ipv6隧道\nFW端\na)启用IPv6路由 ipv6 unicast-routing b)配置双栈接口IPv6地址 interface FastEthernet0/1 ipv6 address 2002::1/64 ipv6 enable no shutdown c)配置隧道接口 interface Tunnel0 ipv6 address 2000::1/64 ipv6 enable no shutdown tunnel source GigabitEthernet0/0/0 tunnel destination 7.0.0.2 tunnel mode ipv6ip d)配置IPv6路由 ipv6 route 2001::/64 2000::2 IPV6_R\na)启用IPv6路由 ipv6 unicast-routing b)配置内部接口IPv6地址 interface GigabitEthernet0/0 ipv6 address 2001::1/64 ipv6 enable no shutdown c)配置隧道接口 interface Tunnel0 ipv6 address 2000::2/64 ipv6 enable no shutdown tunnel source GigabitEthernet0/0/0 tunnel destination 1.0.0.2 tunnel mode ipv6ip d)配置IPv6路由 ipv6 route 2002::/64 2000::1 允许PC33-1访问dmz_srv、禁止访问其它地址、允许所有IP流量 在fw上配置\nFW(config)#access-list 103 permit ip 172.16.33.0 0.0.0.255 172.16.2.0 0.0.0.255 FW(config)#access-list 103 deny ip 172.16.33.0 0.0.0.255 any FW(config)#access-list 103 permit ip any any FW(config)#int f0/0 FW(config-if)#ip access-group 103 in ","permalink":"http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/","summary":"在AS1、AS2、AS3上划分vlan as1 AS1(config)#vlan 10 AS1(config-vlan)#vlan 11 AS1(config-vlan)#int f0/1 AS1(config-if)#switchport mode access AS1(config-if)#switchport access vlan 11 AS1(config-if)#int g0/2 AS1(config-if)#switchport mode access AS1(config-if)#switchport access vlan 10 as2 AS2(config)#vlan 11 AS2(config-vlan)#vlan 22 AS2(config-vlan)#int f0/1 AS2(config-if)#switchport mode access AS2(config-if)#switchport access vlan 11 AS2(config-if)#int f0/2 AS2(config-if)#switchport mode access AS2(config-if)#switchport access vlan 22 as3 AS3(config)#vlan 22 AS3(config-vlan)#vlan 33 AS3(config-vlan)#int f0/1 AS3(config-if)#switchport mode access AS3(config-if)#switchport access vlan 22 AS3(config-if)#int f0/2 AS3(config-if)#switchport mode access AS3(config-if)#switchport access vlan 33 在CS上配置vlan和trunk 在CS配置vlan10、vlan11、vlan22、vlan33、vla","title":"网络设计初测"},{"content":"信息收集与扫描 信息收集是指攻击者多攻击目标进行有计划和有步骤的信息收集从而了解目标的网络环境和信息安全状况的过程。\n攻击目标网络 域名、IP地址、DNS服务器、邮件服务器、网络拓扑结构 攻击目标的个人 身份信息、职业等 收集方法\n注册机构Whois查询 DNS和IP收集 WEB信息检索 网络拓扑侦察 常用工具：\nhttps://whois.aliyun.com/（万网） https://whois.chinaz.com/ dig host fierce nslookup shodan 主机发现 -sL(列表扫描)\n-sP(Ping扫描)\n-Pn(无ping)\n-PS(TCP SYN Ping)\n-PU(UDP Ping)\n-PR(ARP Ping)\n-n(不用域名解析)\n-R(为所有目标解析域名)\nnmap -sP -n -v 192.169.6.0/24 端口扫描 Nmap漏洞扫描\n四种最基本的扫描：\nTCP connect(-sT参数)\nTCP SYN(-sS参数)\nUDP(-sU参数)\nPing(-sP参数)\n端口的几种状态：open(开放的)， closed(关闭的)，和filtered(被过滤的) 状态\n-sS (TCP SYN扫描) SYN扫描作为默认的也是最受欢迎的扫描选项，是有充分理由的。 它执行得很快，在一个没有入侵防火墙的快速网络上，每秒钟可以扫描数千个 端口。 SYN扫描相对来说不张扬，不易被注意到，因为它从来不完成TCP连接。 它也不像Fin/Null/Xmas，Maimon和Idle扫描依赖于特定平台，而可以应对任何兼容的 TCP协议栈。 它还可以明确可靠地区分open(开放的)， closed(关闭的)，和filtered(被过滤的) 状态 它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN/ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。 -sT (TCP connect()扫描) 当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描。 当用户没有权限发送原始报文或者扫描IPv6网络时，就是这种情况。 Instead of writing raw packets as most other scan types do，Nmap通过创建connect() 系统调用要求操作系统和目标机以及端口建立连接，而不像其它扫描类型直接发送原始报文。 这是和Web浏览器，P2P客户端以及大多数其它网络应用程序用以建立连接一样的 高层系统调用。它是叫做Berkeley Sockets API编程接口的一部分。Nmap用 该API获得每个连接尝试的状态信息，而不是读取响应的原始报文。 当SYN扫描可用时，它通常是更好的选择。因为Nmap对高层的 connect()调用比对原始报文控制更少， 所以前者效率较低。 该系统调用完全连接到开放的目标端口而不是像SYN扫描进行 半开放的复位。这不仅花更长时间，需要更多报文得到同样信息，目标机也更可能 记录下连接。IDS(入侵检测系统)可以捕获两者，但大部分机器没有这样的警报系统。 当Nmap连接，然后不发送数据又关闭连接， 许多普通UNIX系统上的服务会在syslog留下记录，有时候是一条加密的错误消息。 此时，有些真正可怜的服务会崩溃，虽然这不常发生。如果管理员在日志里看到来自同一系统的 一堆连接尝试，她应该知道她的系统被扫描了。 -sU (UDP扫描) 虽然互联网上很多流行的服务运行在TCP 协议上，UDP服务也不少。 DNS，SNMP，和DHCP (注册的端口是53，161/162，和67/68)是最常见的三个。 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。 UDP扫描用-sU选项激活。它可以和TCP扫描如 SYN扫描 (-sS)结合使用来同时检查两种协议。 UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是closed(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是filtered(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是open(开放的)。 如果几次重试后还没有响应，该端口就被认为是 open|filtered(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(-sV)帮助区分真正的开放端口和被过滤的端口。 UDP扫描的巨大挑战是怎样使它更快速。 开放的和被过滤的端口很少响应，让Nmap超时然后再探测，以防探测帧或者 响应丢失。关闭的端口常常是更大的问题。 它们一般发回一个ICMP端口无法到达错误。但是不像关闭的TCP端口响应SYN或者Connect 扫描所发送的RST报文，许多主机在默认情况下限制ICMP端口不可到达消息。 Linux和Solaris对此特别严格。例如， Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息 (见net/ipv4/icmp。c)。 秘密扫描：\nFIN扫描 -sF ACK扫描 -sA NULL扫描 -sN XMAS扫描 -sX -sA (TCP ACK扫描) 这种扫描与目前为止讨论的其它扫描的不同之处在于 它不能确定open(开放的)或者 open|filtered(开放或者过滤的))端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。 ACK扫描探测报文只设置ACK标志位(除非您使用 --scanflags)。当扫描未被过滤的系统时， open(开放的)和closed(关闭的) 端口 都会返回RST报文。Nmap把它们标记为 unfiltered(未被过滤的)，意思是 ACK报文不能到达，但至于它们是open(开放的)或者 closed(关闭的) 无法确定。不响应的端口 或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 filtered(被过滤的)。 -sN; -sF; -sX (TCP Null，FIN，and Xmas扫描) 这三种扫描类型 (甚至用下一节描述的 --scanflags 选项的更多类型) 在TCP RFC 中发掘了一个微妙的方法来区分open(开放的)和 closed(关闭的)端口。第65页说“如果 [目标]端口状态是关闭的.... 进入的不含RST的报文导致一个RST响应。” 接下来的一页 讨论不设置SYN，RST，或者ACK位的报文发送到开放端口: “理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 ” 如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK， 任何其它三种(FIN，PSH，and URG)的组合都行。Nmap有三种扫描类型利用这一点： Null扫描 (-sN) 不设置任何标志位(tcp标志头是0) FIN扫描 (-sF) 只设置TCP FIN标志位。 Xmas扫描 (-sX) 设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。 除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是 closed(关闭的)，而没有响应则意味着 端口是open|filtered(开放或者被过滤的)。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为 被过滤的。 这些扫描的关键优势是它们能躲过一些无状态防火墙和报文过滤路由器。 另一个优势是这些扫描类型甚至比SYN扫描还要隐秘一些。但是别依赖它 -- 多数 现代的IDS产品可以发现它们。一个很大的不足是并非所有系统都严格遵循RFC 793。 许多系统不管端口开放还是关闭，都响应RST。 这导致所有端口都标记为closed(关闭的)。 这样的操作系统主要有Microsoft Windows，许多Cisco设备，BSDI，以及IBM OS/400。 但是这种扫描对多数UNIX系统都能工作。这些扫描的另一个不足是 它们不能辨别open(开放的)端口和一些特定的 filtered(被过滤的)端口，从而返回 open|filtered(开放或者被过滤的)。 服务版本检测\u0026amp;\u0026amp;脚本扫描\u0026amp;\u0026amp;OS检测 nmap -v -SV 192.168.7.2 服务版本检测\nnmap -v -O 192.168.7.2 OS检测\nnamp \u0026ndash;script\n","permalink":"http://localhost:1313/posts/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/","summary":"信息收集与扫描 信息收集是指攻击者多攻击目标进行有计划和有步骤的信息收集从而了解目标的网络环境和信息安全状况的过程。 攻击目标网络 域名、IP地址、DNS服务器、邮件服务器、网络拓扑结构 攻击目标的个人 身份信息、职业等 收集方法 注册机构Whois查询 DNS和IP收集 WEB信息检索 网络拓扑侦","title":"信息收集与扫描"}]